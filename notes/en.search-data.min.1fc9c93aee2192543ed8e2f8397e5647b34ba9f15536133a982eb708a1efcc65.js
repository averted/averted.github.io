'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/notes/dev/git/',title:"Git",section:"All",content:"Jan 12, 2014\n Restore Version #  Restore a version of a file to the one before commit h0a0s0h (~1 for 1 above version):\ngit checkout h0a0s0h~1 -- file1/to/restore file2/to/restore Checkout from specific branch #  Example - if your current branch is feature/123, and you\u0026rsquo;re rebasing it on top of master:\ngit checkout feature/123 git rebase master and run into conflicts on some file (src/some/file.js), you can revert this file to master\u0026rsquo;s version with:\ngit checkout master -- src/some/file.js or use ours and theirs aliases:\ngit checkout --ours src/some/file.js git checkout --theirs src/some/file.js Diff between branches #  Show difference between HEAD and specific branch:\ngit diff master src/some/file.js "}),a.add({id:1,href:'/notes/dev/vim/',title:"Vim",section:"All",content:"Buffers #  Navigation #  Navigate through buffers:\n:next | :n | ]] :prev | :p | [[ Open all files returned from grep #  vim $(grep -lri 'pattern' .) Search and replace multiple files #  Open multiple files into buffers:\nvim ./*.js run:\n:bufdo %s/pattern/replace/ge [| update] update flag is optional if you have \u0026lsquo;set hidden\u0026rsquo; vim flag enabled.\nThe same can be accomplished with arglist without loading files into buffers.\nFirst add files to arglist:\n:argadd *.js Then replace with:\n:argdo %s/foo/bar/ge  "}),a.add({id:2,href:'/notes/js/classes/',title:"Classes",section:"JavaScript",content:"Classes #  Overview #   Class declarations, unlike functions, are not hoisted All methods are nonenumerable Calling class constructor without new throws an error (new.target always exists)  Classes as First-Class Citizens #  A first-class citizen is a value that can be passed into a function, returned from a function, and assigned to a variable. Every JS Function is a first-class citizen, and Classes are as well (can be passed around as arguments inside a fn).\nAccessor Properties #  Classes allow you to define accessor properties on the prototype. Ie:\nclass CustomHTMLElement { constructor(elment) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; } } Computed Member Names #  Class methods and accessor properties can also have computed names: Ie:\nconst methodName = \u0026#39;sayName\u0026#39;; const propertyName = \u0026#39;html\u0026#39;; class Person { constructor(name, element) { this.name = name; this.element = element; } [methodName]() { console.log(this.name); } get [propertyName]() { return this.element.innerHTML; } set [propertyName](value) { this.element.innerHTML = value; } } Inheritance with Derived Classes #  Classes that inherit from other classes are called derived classes. Derived classes require you to use super() if you specify a constructor.\nAccepting any type of expression after extends offers powerful possibilities, such as dynamically determining what to inherit from. Ie:\nclass Animal { } function getBase() { return Animal; } class Dog extends getBase() { } And because you can determine the base class dynamically, it\u0026rsquo;s possible to create different inheritance approaches - for example mixins.\nconst SerializableMixin = { serialize() { return JSON.stringify(this); } } const AreaMixin = { getArea() { return this.lenght * this.width; } } function mixin(...mixins) { const base = function() {}; Object.assign(base.prototype, ...mixins); return base; } class Square extends mixin(AreaMixin, SerializableMixin) { constructor(length) { super(); this.width = length; this.length = length; } } let x = new Square(3); x.getArea(); x.serialize(); Symbol.species property #  Any method that returns an instance of a build-in (i.e. Array), will automatically return a derived class instance instead.\nclass MyArray extends Array { } let items = new MyArray(1,2,3,4) , subitems = items.slice(1, 3); console.log(items instance of MyArray); // true console.log(subitems instance of MyArray); // true The Symbol.species is used to define a static accessor property that returns a function.\n// several built-ins use species similar to this class MyClass { static get [Symbol.species]() { return this; } constructor(value) { this.value = value; } clone() { return new this.constructor[Symbol.species](this.value); } } The clone() method uses species to return a new instance rather than directly using MyClass, which allows direved classes to override that value. In general, you should use Symbol.species property whenever you might want to use this.contructor in a class method. Doing so allows deived classes to override the return type easily.\nnew.target in Class Constructors #  You can use new.target in class constructors to determine how the class is being invoked. This is useful because it gives each sontructor the ability to alter it\u0026rsquo;s behaviour. For example you can create an abstract class (a class that can\u0026rsquo;t be initialized directly):\nclass Shape { constructor() { if (new.target === Shape) { throw new Error(\u0026#39;Abstract class: cannot initialize directly\u0026#39;); } } } class Rect extends Shape { } let x = new Shape(); // error let y = new Rect(3, 4); // no error console.log(y instance of Shape); // true Experiments #  class SomeElement { constructor() { this.element = { value: \u0026#39;something\u0026#39;, another: \u0026#39;another\u0026#39;, } } get html() { return this.element.value; } set html(value) { this.element.value = value; } } let some = new SomeElement(); some.html = \u0026#39;test\u0026#39; console.log(some) "}),a.add({id:3,href:'/notes/shell/files/',title:"Files",section:"Shell",content:"August 1, 2018\n Chmod #  Default permission:\nchmod 755 # DIR -rwxr-xr-x chmod 644 # FILE -rw-r--r-- Change all directories to 755:\nfind . -type d -exec chmod 755 {} \\; Change all files to 644 under current directory:\nfind . -type f -exec chmod 644 {} \\; Rename Multiple #  for i in *.js; do mv \u0026quot;$i\u0026quot; \u0026quot;./${i/pattern/replace}\u0026quot;; done Example:\nRename list of files from: ic-one.svg -\u0026gt; one.svg ic-two.svg -\u0026gt; two.svg ic-three.svg -\u0026gt; three.svg for i in *.svg; do mv \u0026quot;$i\u0026quot; \u0026quot;./${i/ic-//}\u0026quot;; done Encrypt / Decrypt #  Show list of ciphers:\nopenssl list-cipher-commands Encrypt file.txt to file.cryp using 256-bit AES in CBC mode:\nopenssl enc -aes-256-cbc -salt -in file.txt -out file.cryp Same as above, only the output is base64 encoded (for e-mails, etc):\nopenssl enc -aes-256-cbc -a -salt -in file.txt -out file.cryp Decrypt binary file.cryp:\nopenssl enc -d -aes-256-cbc -in file.cryp Decrypt base64-encoded version:\nopenssl enc -d -aes-256-cbc -a -in file.cryp "}),a.add({id:4,href:'/notes/shell/networking/',title:"Networking",section:"Shell",content:"December 12, 2020\n WiFi #  Turn off IPv6 on Mac OS:\nnetworksetup -setv6off Wi-Fi "}),a.add({id:5,href:'/notes/ts/all/',title:"All",section:"TypeScript",content:"TypeScript #  Index Signature #  The [key: T]: U is called an index signature, and is the way you tell TS that an object might contain more keys.\nlet a: { b: number c?: string [key: string]: boolean } "}),a.add({id:6,href:'/notes/dev/dom/',title:"DOM",section:"All",content:"Query Params #  Extract query string params (replace qs?) #  Assuming current URL is: ?post=1234\u0026amp;action=edit\nvar urlParams = new URLSearchParams(window.location.search); console.log(urlParams.has(\u0026#39;post\u0026#39;)); // true console.log(urlParams.get(\u0026#39;action\u0026#39;)); // \u0026#34;edit\u0026#34; console.log(urlParams.getAll(\u0026#39;action\u0026#39;)); // [\u0026#34;edit\u0026#34;] console.log(urlParams.toString()); // \u0026#34;?post=1234\u0026amp;action=edit\u0026#34; console.log(urlParams.append(\u0026#39;active\u0026#39;, \u0026#39;1\u0026#39;)); // \u0026#34;?post=1234\u0026amp;action=edit\u0026amp;active=1\u0026#34; "}),a.add({id:7,href:'/notes/js/iterators/',title:"Iterators / Generators",section:"JavaScript",content:"Iterators \u0026amp; Generators #  Iterators #  Iterators are objects with a specific interface designed for iteration. All iterator objects have a next() method that returns a result object. The result object has two proerties: value, which is the next value, and done, which is a Boolean that\u0026rsquo;s true when there are no more values to return. The iterator keeps an internal pointer to a location within a collection of values, and with each call to the next() method it returns the next appropriate value.\nManually creating an iterator using ECMAScript 5 spec:\nfunction createIterator(items) { let i = 0; return { next: function() { let done = (i \u0026gt;= items.length); let value = !done ? items[i++] : undefined; return { done, value }; } } } let iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 2, done: false } console.log(iterator.next()); // { value: 3, done: false } console.log(iterator.next()); // { value: undefined, done: true } Writing iterators manually is a bit complex, fortunately ECMAScript 6 also provides generators, which make creating iterator objects much simpler.\nGenerators #  A generator is a function that returns an iterator. Generator functions are indicated by an asterisk (*) character.\nfunction *createIterator() { yield 1; yield 2; yield 3; } // ------------------------------------------ function *createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } // ------------------------------------------ let createIterator = function *(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } // ------------------------------------------ let obj = { *createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } } // ------------------------------------------  let iterator = obj.createIterator([1,2,3]); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 Perhaps the most interesting aspect generator functions is that they stop execution after each yield statement. You can only use yield keyword inside generators, as yield cannot cross funciton boundaries.\nfunction *createIterator(items) { items.map(function(item) { // syntax error  yield item; }); }  Note: Creating an arrow function that is also a generator is not possible.\n For-of Loops #  Closely related to iterators, an iterable is an object with a Symbol.iterator property, which specifies a function that returns an iterator for the given object. All collection objects (arrays, sets, maps) and strings are iterables in ECMAScript 6, so they have a default iterator specified. All iterators created by generators are also iterables, because generators assign the Symbol.iterator property by default.\nA for-of loop calls next() on an iterable each time the loop executes, and stores the value from result objet in a variable:\nlet items = [1,2,3]; for (let item of items) { console.log(item); } This for-of loop first calls the Symbol.iterator method on the items array to retrieve an iterator (happens behind the scenes), then iterator.next() is called.\nAccessing the Default Iterator #  You can use Symbol.iterator to access the default iterator for an object, like this:\nlet values = [1,2,3]; let iterator = values[Symbol.iterator](); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); Because Symbol.iterator specifies the default iterator, you can use it to detect whether an objet is iterable or not:\nfunction isIterable(obj) { return typeof obj[Symbol.iterator] === \u0026#39;function\u0026#39;; } The for-of loop does a similar check before executing.\nCreating Iterables #  Developer-defined objects are not iterable by default, but you can make them iterable by creating a Symbol.iterator property containing a generator.\nlet collection = { items: [], *[Symbol.iterator]() { for (let item of this.items) { yield item; } } } collection.items.push(1); collection.items.push(2); collection.items.push(3); for (let x of collection) { console.log(x); // 1 2 3 } Spread Operator and Non-Array Iterables #  The spread operator works on all iterables, and uses the default iterator to determine which values to include:\nlet set = new Set([1,2,3,3,3,4,5]); let arr = [...set]; console.log(arr); // [1,2,3,4,5] Advanced Iterator Functionality #  Iterators can be used for tasks other than simply iterating over a collection of values.\nPassing Arguments to Iterators #  You can pass arguments to an iterator through the next() method. That argument becomes the value of yield statement inside a generator:\nfunction *createIterator() { let first = yield 1; let second = yield first + 2; yield second + 3; } let iterator = createIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next(4)); // { value: 6, done: false } console.log(iterator.next(5)); // { value: 8, done: false } console.log(iterator.next()); // { value: undefined, done: true } The first call to next() is a special case where any argument passed to is is lost. Because arguments passed to next() become the values returned by yield, an agrument from the first call to next() could only replace the first yield statement if it could be accessed before that yield statement. That\u0026rsquo;s not possible, so there is no point passing an argument the first time next() is called.\nThrowing Errors in Iterators #  You can catch errors inside the generator using a try-catch block:\nfunction *createIterator() { let first = yield 1; let second; try { second = yield first + 2; } catch () { second = 6; } yield second + 3; } let iterator = createIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next(4)); // { value: 6, done: false } console.log(iterator.throw(new Error())); // { value: 9, done: false } console.log(iterator.next()); // { value: undefined, done: true } Generator Return Statements #  Because generators are functions, you can use the return statement to exit early, and specify a return value for the last call to the next() method.\nfunction *createIterator() { yield 1; return 42; } let iterator = createIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 42, done: true }  Note: The spread operator and for-of loop ignore any value specified by a return statement.\n Delegating Generators #  Generators can delegate to other generator using a special form of yield with an asterisk (*). I.e:\nfunction *createNumberIterator() { yield 1; yield 2; } function *createColorIterator() { yield \u0026#39;red\u0026#39;; yield \u0026#39;green\u0026#39;; } function *createCombinedIterator() { yield *createNumberIterator(); yield *createColorIterator(); yield true; } let iterator = createCombinedIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 2, done: false } console.log(iterator.next()); // { value: \u0026#39;red\u0026#39;, done: false } console.log(iterator.next()); // { value: \u0026#39;green\u0026#39;, done: false } console.log(iterator.next()); // { value: true, done: false } console.log(iterator.next()); // { value: undefined, done: true } Generator delegation also lets you make further use of generator return values. It\u0026rsquo;s the easiest way to access returned values and can be useful when performing complex tasks.\nfunction *createNumberIterator() { yield 1; yield 2; return 4; } function *createRepeatingIterator(count) { for (let i = 0; i \u0026lt; count; i++) { yield \u0026#39;repeat\u0026#39;; } } function *createCombinedIterator() { let result = yield *createNumberIterator(); yield result; yield *createRepeatingIterator(result); } let iterator = createCombinedIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 2, done: false } console.log(iterator.next()); // { value: 4, done: false } console.log(iterator.next()); // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()); // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()); // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()); // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()); // { value: undefined, done: true }  Note: You can use yield * directly on strings (ie. yield * 'hello'), and string\u0026rsquo;s default iterator will be used.\n Asynchronous Task Running #  Much of the excitement around generators is related to async programming, especially when you\u0026rsquo;re trying to run a sequence of async calls. Because yield stops executiong and wiats for the next() method to be called before starting again, you can implement async calls without managing callbacks.\nExample of a simple synchronous task runner:\nfunctino run (taskGenerator) { let task = taskGenerator(); // start task  let result = task.next(); // recursion to keep calling next()  function step() { if (!result.done) { result = task.next(result.value); step(); } } step(); } Passing result.value into task.next as an argument, it\u0026rsquo;s possible to pass data between yield calls like this:\nrun(function*() { let value = yield 1; value = yield value + 3; }); Example of async task runner (just pass a callback Fn into result.value):\nlet fs = require(\u0026#39;fs\u0026#39;); function run(taskGenerator) { let task = taskGenerator(); let result = task.next(); function step() { if (!result.done) { if (typeof result.value === \u0026#39;function\u0026#39;) { result.value((err, data) =\u0026gt; { if (err) { result = task.throw(err); return; } result = task.next(data); step(); }); } else { result = task.next(result.value); step(); } } } step(); } const readFile = (filename) =\u0026gt; (cb) =\u0026gt; { fs.readFile(filename, cb) } run(function*() { let contents = yield readFile(\u0026#39;config.json\u0026#39;): console.log(\u0026#39;Done\u0026#39;); }); Above example performs async readFile() operation withou making any callbakcs visible in the main code. Aside from yield the code looks the same as synch code.\nExperiments #  class Collection { constructor(items) { this.items = items || []; } *[Symbol.iterator]() { for (let i = 0; i \u0026lt; this.items.length; i++) { yield this.items[i]; } // OR  // yield *this.items.values();  } map(fn) { let result = []; if (typeof fn === \u0026#39;function\u0026#39;) { for (let item of this) { result.push(fn(item, this.items.indexOf(item))); } } return result; } add(item) { this.items.push(item); } remove(item) { const idx = this.items.indexOf(item); if (idx \u0026gt; -1) { this.items.splice(idx, 1); } } removeAt(idx) { if (this.items[idx]) { this.items.splice(idx, 1); } } } class PaginatedCollection extends Collection { constructor(props) { super(props); this.pagination = { pages: 10, current: 0, } } } const objects = [{ a: \u0026#39;a\u0026#39; }, { b: \u0026#39;b\u0026#39; }, { c: \u0026#39;c\u0026#39; }]; let p = new PaginatedCollection(objects); let added = { added: \u0026#39;added\u0026#39; }; p.add(added); p.add({ d: \u0026#39;d\u0026#39; }); p.remove(added); console.log(\u0026#39;-- paginated\u0026#39;, p) let test = p.map((item, idx) =\u0026gt; { console.log(item, idx); if (item.a) { return item; } }); console.log(\u0026#39;-- test\u0026#39;, test) "}),a.add({id:8,href:'/notes/dev/osx/',title:"OSX",section:"All",content:"TN2450 (Remapping Keys) #  https://developer.apple.com/library/archive/technotes/tn2450/_index.html\n"}),a.add({id:9,href:'/notes/shell/postgres/',title:"Postgres",section:"Shell",content:"December 12, 2018\n Connect #  psql -hlocalhost -Uusername -W -ddatabasename Dump #  pg_dump -hlocalhost -Upostgres dbname \u0026gt; ~/dump.sql "})})()